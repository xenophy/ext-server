<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/*!
 * Ext Server
 * Copyright (c)2012 Xenophy.CO.,LTD All rights Reserved.
 * MIT Licensed
 */

// {{{ Ext.Class

<span id='Ext-Class'>/**
</span> * @class Ext.Class
 *
 * {Ext_Class:doc-contents}
 */
(function() {

    var ExtClass,
        Base = Ext.Base,
        baseStaticMembers = [],
        baseStaticMember, baseStaticMemberLength;

    for(baseStaticMember in Base) {
        if(Base.hasOwnProperty(baseStaticMember)) {
            baseStaticMembers.push(baseStaticMember);
        }
    }

    baseStaticMemberLength = baseStaticMembers.length;

    // Creates a constructor that has nothing extra in its scope chain.
    function makeCtor(className) {
        function constructor() {
            return this.constructor.apply(this, arguments);
        }
        //&lt;debug&gt;
        if(className) {
            constructor.displayName = className;
        }
        //&lt;/debug&gt;
        return constructor;
    }

<span id='Ext-Class'>    /**
</span>     * {Ext_Class:method-create:desc}
     *
     * @param {Object} data {Ext_Class:method-create:param_data}
     * @param {Function} onCreated {Ext_Class:method-create:param_onCreated}
     *
     * @return {Ext.Base} {Ext_Class:method-create:return}
     */
    Ext.Class = ExtClass = function(Class, data, onCreated) {

        if(typeof Class != 'function') {
            onCreated = data;
            data = Class;
            Class = null;
        }

        if(!data) {
            data = {};
        }

        Class = ExtClass.create(Class, data);

        ExtClass.process(Class, data, onCreated);

        return Class;
    };

    Ext.apply(ExtClass, {

<span id='Ext-Class-method-onBeforeCreated'>        /**
</span>         * @private
         * @param Class
         * @param data
         * @param hooks
         */
        onBeforeCreated: function(Class, data, hooks) {
            Class.addMembers(data);

            hooks.onCreated.call(Class, Class);
        },

<span id='Ext-Class-method-create'>        /**
</span>         * @private
         * @param Class
         * @param classData
         * @param onClassCreated
         */
        create: function(Class, data) {
            var name, i;

            if(!Class) {
                // This &quot;helped&quot; a bit in IE8 when we create 450k instances (3400ms-&gt;2700ms),
                // but removes some flexibility as a result because overrides cannot override
                // the constructor method... kept in case we want to reconsider because it is
                // more involved than just use the pass 'constructor'
                //
                //if(data.hasOwnProperty('constructor')) {
                //    Class = data.constructor;
                //    delete data.constructor;
                //    Class.$owner = Class;
                //    Class.$name = 'constructor';
                //} else {
                Class = makeCtor(
                    //&lt;debug&gt;
                    data.$className
                    //&lt;/debug&gt;
                );
                //}
            }

            for(i = 0; i &lt; baseStaticMemberLength; i++) {
                name = baseStaticMembers[i];
                Class[name] = Base[name];
            }

            return Class;
        },

<span id='Ext-Class-method-process'>        /**
</span>         * @private
         * @param Class
         * @param data
         * @param onCreated
         */
        process: function(Class, data, onCreated) {
            var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors,
                registeredPreprocessors = this.preprocessors,
                hooks = {
                    onBeforeCreated: this.onBeforeCreated
                },
                preprocessors = [],
                preprocessor, preprocessorsProperties,
                i, ln, j, subLn, preprocessorProperty, process;

            delete data.preprocessors;

            for(i = 0,ln = preprocessorStack.length; i &lt; ln; i++) {
                preprocessor = preprocessorStack[i];

                if(typeof preprocessor == 'string') {
                    preprocessor = registeredPreprocessors[preprocessor];
                    preprocessorsProperties = preprocessor.properties;

                    if(preprocessorsProperties === true) {
                        preprocessors.push(preprocessor.fn);
                    }
                    else if(preprocessorsProperties) {
                        for(j = 0,subLn = preprocessorsProperties.length; j &lt; subLn; j++) {
                            preprocessorProperty = preprocessorsProperties[j];

                            if(data.hasOwnProperty(preprocessorProperty)) {
                                preprocessors.push(preprocessor.fn);
                                break;
                            }
                        }
                    }
                }
                else {
                    preprocessors.push(preprocessor);
                }
            }

            hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
            hooks.preprocessors = preprocessors;

            this.doProcess(Class, data, hooks);
        },
        
        doProcess: function(Class, data, hooks){
            var me = this,
                preprocessor = hooks.preprocessors.shift();

            if(!preprocessor) {
                hooks.onBeforeCreated.apply(me, arguments);
                return;
            }

            if(preprocessor.call(me, Class, data, hooks, me.doProcess) !== false) {
                me.doProcess(Class, data, hooks);
            }
        },

<span id='Ext-Class-property-preprocessors'>        /** @private */
</span>        preprocessors: {},

<span id='Ext-Class-static-method-registerPreprocessor'>        /**
</span>         * {Ext_Class:method-registerPreprocessor:desc}
         *
         * @param {String} name {Ext_Class:method-registerPreprocessor:param_name}
         * @param {Function} fn {Ext_Class:method-registerPreprocessor:param_fn}
         * @param {Function} fn.cls {Ext_Class:method-registerPreprocessor:param_fn.cls}
         * @param {Object} fn.data {Ext_Class:method-registerPreprocessor:param_fn.data}
         * @param {Function} fn.fn {Ext_Class:method-registerPreprocessor:param_fn.fn}
         * @return {Ext.Class} {Ext_Class:method-registerPreprocessor:return} 
         * @private
         * @static
         */
        registerPreprocessor: function(name, fn, properties, position, relativeTo) {
            if(!position) {
                position = 'last';
            }

            if(!properties) {
                properties = [name];
            }

            this.preprocessors[name] = {
                name: name,
                properties: properties || false,
                fn: fn
            };

            this.setDefaultPreprocessorPosition(name, position, relativeTo);

            return this;
        },

<span id='Ext-Class-static-method-getPreprocessor'>        /**
</span>         * {Ext_Class:method-getPreprocessor:desc}
         *
         * @param {String} name {Ext_Class:method-getPreprocessor:param_name}
         * @return {Function} {Ext_Class:method-getPreprocessor:return}
         * @private
         * @static
         */
        getPreprocessor: function(name) {
            return this.preprocessors[name];
        },

<span id='Ext-Class-method-getPreprocessors'>        /**
</span>         * @private
         */
        getPreprocessors: function() {
            return this.preprocessors;
        },

<span id='Ext-Class-property-defaultPreprocessors'>        /**
</span>         * @private
         */
        defaultPreprocessors: [],

<span id='Ext-Class-static-method-getDefaultPreprocessors'>        /**
</span>         * {Ext_Class:method-getDefaultPreprocessors:desc}
         * @return {Function[]} defaultPreprocessors {Ext_Class:method-getDefaultPreprocessors:return}
         * @private
         * @static
         */
        getDefaultPreprocessors: function() {
            return this.defaultPreprocessors;
        },

<span id='Ext-Class-static-method-setDefaultPreprocessors'>        /**
</span>         * {Ext_Class:method-setDefaultPreprocessors:desc}
         *
         * @private
         * @param {Array} preprocessors {Ext_Class:method-setDefaultPreprocessors:param_preprocesors}
         * @return {Ext.Class} {Ext_Class:method-setDefaultPreprocessors:return}
         * @static
         */
        setDefaultPreprocessors: function(preprocessors) {
            this.defaultPreprocessors = Ext.Array.from(preprocessors);

            return this;
        },

<span id='Ext-Class-static-method-setDefaultPreprocessorPosition'>        /**
</span>         * Insert this pre-processor at a specific position in the stack, optionally relative to
         * any existing pre-processor. For example:
         *
         *     Ext.Class.registerPreprocessor('debug', function(cls, data, fn) {
         *         // Your code here
         *
         *         if(fn) {
         *             fn.call(this, cls, data);
         *         }
         *     }).setDefaultPreprocessorPosition('debug', 'last');
         *
         * @private
         * @param {String} name The pre-processor name. Note that it needs to be registered with
         * {@link Ext#registerPreprocessor registerPreprocessor} before this
         * @param {String} offset The insertion position. Four possible values are:
         * 'first', 'last', or: 'before', 'after' (relative to the name provided in the third argument)
         * @param {String} relativeName
         * @return {Ext.Class} this
         * @static
         */
        setDefaultPreprocessorPosition: function(name, offset, relativeName) {
            var defaultPreprocessors = this.defaultPreprocessors,
                index;

            if(typeof offset == 'string') {
                if(offset === 'first') {
                    defaultPreprocessors.unshift(name);

                    return this;
                }
                else if(offset === 'last') {
                    defaultPreprocessors.push(name);

                    return this;
                }

                offset = (offset === 'after') ? 1 : -1;
            }

            index = Ext.Array.indexOf(defaultPreprocessors, relativeName);

            if(index !== -1) {
                Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
            }

            return this;
        },

        configNameCache: {},

        getConfigNameMap: function(name) {
            var cache = this.configNameCache,
                map = cache[name],
                capitalizedName;

            if(!map) {
                capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);

                map = cache[name] = {
                    internal: name,
                    initialized: '_is' + capitalizedName + 'Initialized',
                    apply: 'apply' + capitalizedName,
                    update: 'update' + capitalizedName,
                    'set': 'set' + capitalizedName,
                    'get': 'get' + capitalizedName,
                    doSet : 'doSet' + capitalizedName,
                    changeEvent: name.toLowerCase() + 'change'
                };
            }

            return map;
        }
    });

<span id='Ext-Class-cfg-extend'>    /**
</span>     * @cfg {String} extend
     * {Ext_Class:config-extend:desc}
     */
    ExtClass.registerPreprocessor('extend', function(Class, data) {
        var Base = Ext.Base,
            basePrototype = Base.prototype,
            extend = data.extend,
            Parent, parentPrototype, i;

        delete data.extend;

        if(extend &amp;&amp; extend !== Object) {
            Parent = extend;
        }
        else {
            Parent = Base;
        }

        parentPrototype = Parent.prototype;

        if(!Parent.$isClass) {
            for(i in basePrototype) {
                if(!parentPrototype[i]) {
                    parentPrototype[i] = basePrototype[i];
                }
            }
        }

        Class.extend(Parent);

        Class.triggerExtended.apply(Class, arguments);

        if(data.onClassExtended) {
            Class.onExtended(data.onClassExtended);
            delete data.onClassExtended;
        }

    }, true);

    //&lt;feature classSystem.statics&gt;
<span id='Ext-Class-cfg-statics'>    /**
</span>     * @cfg {Object} statics
     * {Ext_Class:config-statics:desc}
     */
    ExtClass.registerPreprocessor('statics', function(Class, data) {
        Class.addStatics(data.statics);

        delete data.statics;
    });
    //&lt;/feature&gt;

    //&lt;feature classSystem.inheritableStatics&gt;
<span id='Ext-Class-cfg-inheritableStatics'>    /**
</span>     * @cfg {Object} inheritableStatics
     * {Ext_Class:config-inheritableStatics:desc}
     */
    ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
        Class.addInheritableStatics(data.inheritableStatics);

        delete data.inheritableStatics;
    });
    //&lt;/feature&gt;

    //&lt;feature classSystem.config&gt;
<span id='Ext-Class-cfg-config'>    /**
</span>     * @cfg {Object} config
     * {Ext_Class:config-config:desc}
     */
    ExtClass.registerPreprocessor('config', function(Class, data) {
        var config = data.config,
            prototype = Class.prototype;

        delete data.config;

        Ext.Object.each(config, function(name, value) {
            var nameMap = ExtClass.getConfigNameMap(name),
                internalName = nameMap.internal,
                initializedName = nameMap.initialized,
                applyName = nameMap.apply,
                updateName = nameMap.update,
                setName = nameMap.set,
                getName = nameMap.get,
                hasOwnSetter = (setName in prototype) || data.hasOwnProperty(setName),
                hasOwnApplier = (applyName in prototype) || data.hasOwnProperty(applyName),
                hasOwnUpdater = (updateName in prototype) || data.hasOwnProperty(updateName),
                optimizedGetter, customGetter;

            if(value === null || (!hasOwnSetter &amp;&amp; !hasOwnApplier &amp;&amp; !hasOwnUpdater)) {
                prototype[internalName] = value;
                prototype[initializedName] = true;
            }
            else {
                prototype[initializedName] = false;
            }

            if(!hasOwnSetter) {
                data[setName] = function(value) {
                    var oldValue = this[internalName],
                        applier = this[applyName],
                        updater = this[updateName];

                    if(!this[initializedName]) {
                        this[initializedName] = true;
                    }

                    if(applier) {
                        value = applier.call(this, value, oldValue);
                    }

                    if(typeof value != 'undefined') {
                        this[internalName] = value;

                        if(updater &amp;&amp; value !== oldValue) {
                            updater.call(this, value, oldValue);
                        }
                    }

                    return this;
                };
            }

            if(!(getName in prototype) || data.hasOwnProperty(getName)) {
                customGetter = data[getName] || false;

                if(customGetter) {
                    optimizedGetter = function() {
                        return customGetter.apply(this, arguments);
                    };
                }
                else {
                    optimizedGetter = function() {
                        return this[internalName];
                    };
                }

                data[getName] = function() {
                    var currentGetter;

                    if(!this[initializedName]) {
                        this[initializedName] = true;
                        this[setName](this.config[name]);
                    }

                    currentGetter = this[getName];

                    if('$previous' in currentGetter) {
                        currentGetter.$previous = optimizedGetter;
                    }
                    else {
                        this[getName] = optimizedGetter;
                    }

                    return optimizedGetter.apply(this, arguments);
                };
            }
        });

        Class.addConfig(config, true);
    });
    //&lt;/feature&gt;

    //&lt;feature classSystem.mixins&gt;
<span id='Ext-Class-cfg-mixins'>    /**
</span>     * @cfg {String[]/Object} mixins
     * {Ext_Class:config-mixins:desc}
     */
    ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
        var mixins = data.mixins,
            name, mixin, i, ln;

        delete data.mixins;

        Ext.Function.interceptBefore(hooks, 'onCreated', function() {
            if(mixins instanceof Array) {
                for(i = 0,ln = mixins.length; i &lt; ln; i++) {
                    mixin = mixins[i];
                    name = mixin.prototype.mixinId || mixin.$className;

                    Class.mixin(name, mixin);
                }
            }
            else {
                for(var mixinName in mixins) {
                    if(mixins.hasOwnProperty(mixinName)) {
                        Class.mixin(mixinName, mixins[mixinName]);
                    }
                }
            }
        });
    });
    //&lt;/feature&gt;

    Ext.extend = function(Class, Parent, members) {

        if(arguments.length === 2 &amp;&amp; Ext.isObject(Parent)) {
            members = Parent;
            Parent = Class;
            Class = null;
        }

        var cls;

        if(!Parent) {
            throw new Error(&quot;[Ext.extend] Attempting to extend from a class which has not been loaded on the page.&quot;);
        }

        members.extend = Parent;
        members.preprocessors = [
            'extend'
            //&lt;feature classSystem.statics&gt;
            ,'statics'
            //&lt;/feature&gt;
            //&lt;feature classSystem.inheritableStatics&gt;
            ,'inheritableStatics'
            //&lt;/feature&gt;
            //&lt;feature classSystem.mixins&gt;
            ,'mixins'
            //&lt;/feature&gt;
            //&lt;feature classSystem.config&gt;
            ,'config'
            //&lt;/feature&gt;
        ];

        if(Class) {
            cls = new ExtClass(Class, members);
        } else {
            cls = new ExtClass(members);
        }

        cls.prototype.override = function(o) {
            for(var m in o) {
                if(o.hasOwnProperty(m)) {
                    this[m] = o[m];
                }
            }
        };

        return cls;
    };

}());

// }}}

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
